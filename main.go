package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joho/godotenv"

	"github.com/matwate/proyecto-datos/db"
	_ "github.com/matwate/proyecto-datos/docs" // docs is generated by Swag CLI
	"github.com/matwate/proyecto-datos/handler"
)

// @title        Proyecto de Ingenieria de  Datos API
// @version      1.0
// @description  This is the API for my project.
// @termsOfService http://swagger.io/terms/
// @host      matwa.tail013c29.ts.net
// @BasePath  /api/
// @schemes   https
func main() {
	// Load environment variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using environment variables")
	}

	dbURL := os.Getenv("POSTGRES_URL")
	if dbURL == "" {
		log.Fatal("POSTGRES_URL environment variable is not set")
	}

	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		log.Fatalf("Unable to create connection pool: %v\n", err)
	}
	defer pool.Close()

	queries := db.New(pool)
	mux := http.NewServeMux()

	mux.HandleFunc("/v1/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		fmt.Fprintln(w, "OK HEALTHY")
	})

	// Unified Authentication Handler
	unifiedLoginHandler := handler.UnifiedLoginHandler(queries)
	mux.Handle("POST /v1/login/{mode}", unifiedLoginHandler) // Path prefix for /v1/login/{mode}

	// Estudiante Handlers
	estudianteHandlers := handler.EstudianteHandlers(queries)
	mux.Handle("/v1/estudiantes", estudianteHandlers)
	mux.Handle("/v1/estudiantes/", estudianteHandlers)

	// Tutor Handlers
	tutorHandlers := handler.TutorHandlers(queries)
	mux.Handle("/v1/tutores", tutorHandlers)
	mux.Handle("/v1/tutores/", tutorHandlers)

	// New comprehensive CRUD handlers using Go 1.24 routing patterns
	materiaHandlers := handler.MateriaHandlers(queries)
	mux.Handle("/v1/materias", materiaHandlers)
	mux.Handle("/v1/materias/", materiaHandlers)

	disponibilidadHandlers := handler.DisponibilidadHandlers(queries)
	mux.Handle("/v1/disponibilidad", disponibilidadHandlers)
	mux.Handle("/v1/disponibilidad/", disponibilidadHandlers)

	tutoriaHandlers := handler.TutoriaHandlers(queries)
	mux.Handle("/v1/tutorias", tutoriaHandlers)
	mux.Handle("/v1/tutorias/", tutoriaHandlers)

	// Specific endpoints for tutoria updates using Go 1.22 routing patterns
	mux.HandleFunc("PATCH /v1/tutorias/{id}/estado", handler.UpdateTutoriaEstadoEndpoint(queries))
	mux.HandleFunc("PATCH /v1/tutorias/{id}/asistencia", handler.UpdateTutoriaAsistenciaEndpoint(queries))

	// Specific endpoints for selecting tutorias by tutor or estudiante ID
	mux.HandleFunc("GET /v1/tutorias/tutor/{tutor_id}", func(w http.ResponseWriter, r *http.Request) {
		handler.SelectTutoriaByTutorIDHandler(w, r, queries)
	})
	mux.HandleFunc("GET /v1/tutorias/estudiante/{estudiante_id}", func(w http.ResponseWriter, r *http.Request) {
		handler.SelectTutoriaByEstudianteIDHandler(w, r, queries)
	})

	// Endpoint to get materias for a specific tutor
	mux.HandleFunc("GET /v1/tutores/{id}/materias", func(w http.ResponseWriter, r *http.Request) {
		handler.GetTutorMateriasHandler(w, r, queries)
	})

	reporteHandlers := handler.ReporteHandlers(queries)
	mux.Handle("/v1/reportes", reporteHandlers)
	mux.Handle("/v1/reportes/", reporteHandlers)

	tutorMateriaHandlers := handler.TutorMateriaHandlers(queries)
	mux.Handle("/v1/tutor-materias", tutorMateriaHandlers)
	mux.Handle("/v1/tutor-materias/", tutorMateriaHandlers)

	mux.HandleFunc("/v1/docs/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		html := `<!DOCTYPE html>
<html>
  <head>
    <title>Redoc</title>
    <!-- needed for adaptive design -->
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">

    <!--
    Redoc doesn't change outer page styles
    -->
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <redoc spec-url='https://matwa.tail013c29.ts.net/api/v1/docs/swagger.yaml'></redoc>
    <script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"> </script>
  </body>
</html>
`
		fmt.Fprint(w, html)
	})

	mux.HandleFunc("/v1/docs/swagger.yaml", func(w http.ResponseWriter, r *http.Request) {
		content, err := os.ReadFile("./docs/swagger.yaml")
		if err != nil {
			log.Printf("Error reading swagger.yaml: %v", err)
			http.Error(w, "Could not read swagger.yaml", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "text/yaml; charset=utf-8")
		w.Header().Set("Access-Control-Allow-Origin", "*") // Add CORS header
		w.WriteHeader(http.StatusOK)
		_, err = w.Write(content)
		if err != nil {
			log.Printf("Error writing swagger.yaml to response: %v", err)
			// Client might have already received headers, so we can't send another http.Error
		}
	})

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port if not specified
	}

	// Apply global middleware
	wrappedMux := use(mux, handler.LoggingMiddleware, handler.CORSMiddleware) // Apply LoggingMiddleware and CORSMiddleware globally

	log.Printf("Starting server on port %s...\n", port)
	if err := http.ListenAndServe(":"+port, wrappedMux); err != nil { // Use wrappedMux
		log.Fatalf("Could not start server: %s\n", err)
	}
}

func use(
	r http.Handler,
	middlewares ...func(next http.Handler) http.Handler,
) http.Handler { // Changed r to http.Handler
	s := r
	for _, mw := range middlewares {
		s = mw(s)
	}
	return s
}
